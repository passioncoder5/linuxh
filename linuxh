#!/usr/bin/env bash
#
# linuxh - Linux Hardening & Inspection Tool (safe-by-default)
# Author: Converted from user script - safe CLI tool
# Version: 1.1
#
# Defaults:
#  - DRY-RUN mode by default (no destructive actions).
#  - To actually perform destructive actions: pass --apply
#  - To auto-confirm prompts (dangerous): pass --yes --apply
#
set -euo pipefail

# -------------------------
# Configuration (customize)
# -------------------------
SUSPICIOUS_PORTS=(4444 1337 31337 6667 9999 12345 54321)
ESSENTIAL_PORTS=(22 80 443)
BACKUP_DIR_DEFAULT="/root/security_backup_$(date +%Y%m%d_%H%M%S)"
LOG_FILE_DEFAULT="/var/log/linuxh_security.log"

# -------------------------
# Runtime flags (defaults)
# -------------------------
DRY_RUN=1        # default: dry-run
FORCE_NO_PROMPT=0
BACKUP_DIR="$BACKUP_DIR_DEFAULT"
LOG_FILE="$LOG_FILE_DEFAULT"

# -------------------------
# Colors for output
# -------------------------
RED=$'\033[0;31m'; GREEN=$'\033[0;32m'; YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'; NC=$'\033[0m'

# -------------------------
# Utility / Logging
# -------------------------
log() {
    local msg="$1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $msg" | tee -a "$LOG_FILE"
}
info()    { log "INFO: $1"; echo -e "${BLUE}ℹ $1${NC}"; }
success() { log "SUCCESS: $1"; echo -e "${GREEN}✅ $1${NC}"; }
warn()    { log "WARNING: $1"; echo -e "${YELLOW}⚠ $1${NC}"; }
err()     { log "ERROR: $1"; echo -e "${RED}❌ $1${NC}"; }

# Wrapper to either show command (dry-run) or execute it
run_cmd() {
    local cmd="$*"
    if [[ $DRY_RUN -eq 1 ]]; then
        echo "[DRY-RUN] $cmd"
        log "[DRY-RUN] $cmd"
    else
        eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
    fi
}

# Prompt helpers
prompt_yes_no() {
    local prompt="${1:-Continue?}"
    local default="${2:-no}"

    if [[ $FORCE_NO_PROMPT -eq 1 ]]; then
        return 0
    fi

    while true; do
        read -rp "$prompt [y/N]: " response || return 1
        response="${response:-$default}"
        case "$response" in
            [Yy]* ) return 0 ;;
            [Nn]* ) return 1 ;;
            * ) echo "Please answer yes or no." ;;
        esac
    done
}

ensure_root_for_apply() {
    # Only require root if actually applying changes (--apply)
    if [[ $DRY_RUN -eq 0 && $EUID -ne 0 ]]; then
        err "This operation requires root. Run as root or use sudo when passing --apply."
        exit 1
    fi
}

# -------------------------
# Safe backup helper
# -------------------------
make_backup_dir() {
    if [[ -z "$BACKUP_DIR" ]]; then
        BACKUP_DIR="$BACKUP_DIR_DEFAULT"
    fi
    if [[ $DRY_RUN -eq 1 ]]; then
        echo "[DRY-RUN] mkdir -p '$BACKUP_DIR'"
    else
        mkdir -p "$BACKUP_DIR"
        success "Backup directory: $BACKUP_DIR"
    fi
}

create_backup() {
    local file="$1"
    if [[ -z "$file" || ! -e "$file" ]]; then
        return 0
    fi
    local base
    base="$(basename "$file")"
    local bfile="$BACKUP_DIR/${base}.backup.$(date +%H%M%S)"
    run_cmd cp -a -- "$file" "$bfile"
    if [[ $DRY_RUN -eq 0 ]]; then
        success "Backed up $file -> $bfile"
    fi
}

# -------------------------
# Functional modules (safe)
# -------------------------

# 1) Gather network info (non-destructive)
get_network_info() {
    info "Gathering network connection information..."
    if command -v ss &>/dev/null; then
        ss -tunlp 2>/dev/null || true
    elif command -v netstat &>/dev/null; then
        netstat -tunlp 2>/dev/null || true
    else
        err "Neither ss nor netstat found."
        return 1
    fi
}

analyze_connections() {
    info "Analyzing connections for suspicious ports: ${SUSPICIOUS_PORTS[*]}"
    local output
    output="$(get_network_info || true)"
    local matches=0
    while IFS= read -r line; do
        for port in "${SUSPICIOUS_PORTS[@]}"; do
            if echo "$line" | grep -q -E "[:.]${port}([[:space:]]|$)"; then
                matches=$((matches+1))
                echo "[$matches] $line"
            fi
        done
    done <<<"$output"

    if [[ $matches -eq 0 ]]; then
        success "No suspicious connections found."
    else
        warn "Found $matches suspicious connection(s). Use --manage-processes to investigate PIDs."
    fi
}

# Helper to extract pid from ss/netstat lines (best-effort)
extract_pid_from_line() {
    local line="$1"
    # patterns like "users:(("pid",fd))" or "pid/program"
    local pid=""
    pid="$(echo "$line" | grep -oE 'pid=[0-9]+' | head -1 | cut -d= -f2 || true)"
    if [[ -z "$pid" ]]; then
        pid="$(echo "$line" | grep -oE '[0-9]+/[^[:space:]]+' | head -1 | cut -d'/' -f1 || true)"
    fi
    echo "${pid:-}"
}

get_proc_path() {
    local pid="$1"
    if [[ -d "/proc/$pid" ]]; then
        readlink -f "/proc/$pid/exe" 2>/dev/null || echo "Unknown"
    else
        echo "Unknown"
    fi
}

# 2) Find & manage suspicious processes - FIXED VERSION
manage_suspicious_processes() {
    info "Scanning for processes listening on suspicious ports..."
    local netinfo
    netinfo="$(get_network_info || true)"
    
    # Initialize the associative array properly
    declare -A found=()
    
    while IFS= read -r line; do
        for port in "${SUSPICIOUS_PORTS[@]}"; do
            if echo "$line" | grep -q -E "[:.]${port}([[:space:]]|$)"; then
                local pid
                pid="$(extract_pid_from_line "$line")"
                if [[ -n "$pid" ]]; then
                    found["$pid"]=1
                fi
            fi
        done
    done <<<"$netinfo"

    if [[ ${#found[@]} -eq 0 ]]; then
        success "No suspicious processes found."
        return 0
    fi

    make_backup_dir

    for pid in "${!found[@]}"; do
        local exe
        exe="$(get_proc_path "$pid")"
        echo "PID: $pid - Path: $exe"
        if prompt_yes_no "Would you like to kill PID $pid?"; then
            ensure_root_for_apply
            if prompt_yes_no "Confirm kill PID $pid (this is destructive)"; then
                run_cmd "kill -9 $pid" || true
                success "Requested kill for $pid (or shown in dry-run)."
            fi
        fi

        if [[ "$exe" != "Unknown" && -f "$exe" ]]; then
            if prompt_yes_no "Backup then remove executable: $exe"; then
                create_backup "$exe"
                if prompt_yes_no "Confirm removal of $exe (destructive)"; then
                    ensure_root_for_apply
                    run_cmd "rm -f -- '$exe'"
                    success "Requested removal of $exe (or shown in dry-run)."
                fi
            fi
        fi
        echo "----"
    done
}

# Auto-detect package manager
detect_package_manager() {
    if command -v apt &>/dev/null; then
        echo "apt"
    elif command -v yum &>/dev/null; then
        echo "yum"
    elif command -v dnf &>/dev/null; then
        echo "dnf"
    elif command -v zypper &>/dev/null; then
        echo "zypper"
    elif command -v pacman &>/dev/null; then
        echo "pacman"
    else
        echo "unknown"
    fi
}

# Install package with detected package manager
install_package() {
    local pkg="$1"
    local pm="$2"
    
    case "$pm" in
        apt)
            run_cmd "DEBIAN_FRONTEND=noninteractive apt update && DEBIAN_FRONTEND=noninteractive apt install -y '$pkg'"
            ;;
        yum|dnf)
            run_cmd "$pm install -y '$pkg'"
            ;;
        zypper)
            run_cmd "zypper -n install '$pkg'"
            ;;
        pacman)
            run_cmd "pacman -S --noconfirm '$pkg'"
            ;;
        *)
            err "Unsupported package manager: $pm"
            return 1
            ;;
    esac
}

# 3) Firewall (UFW) configuration helper
setup_ufw_firewall() {
    info "UFW firewall configuration helper."
    if ! command -v ufw &>/dev/null; then
        warn "UFW not installed."
        if prompt_yes_no "Install UFW now?"; then
            ensure_root_for_apply
            local pm
            pm=$(detect_package_manager)
            install_package "ufw" "$pm"
        else
            warn "Skipping UFW installation."
            return 0
        fi
    fi

    info "Inspecting UFW status..."
    if [[ $DRY_RUN -eq 1 ]]; then
        ufw status || true
        echo "[DRY-RUN] Would set defaults: deny incoming, allow outgoing and allow ports: ${ESSENTIAL_PORTS[*]}"
    else
        local status
        status="$(ufw status 2>/dev/null || echo "inactive")"
        info "Current UFW status: $status"
        if prompt_yes_no "Reset UFW to defaults and configure?"; then
            ensure_root_for_apply
            run_cmd "ufw --force reset"
            run_cmd "ufw default deny incoming"
            run_cmd "ufw default allow outgoing"
            for p in "${ESSENTIAL_PORTS[@]}"; do
                if prompt_yes_no "Allow port $p?"; then
                    run_cmd "ufw allow $p"
                fi
            done
            if prompt_yes_no "Enable UFW now?"; then
                run_cmd "ufw --force enable"
                success "UFW enabled (or shown in dry-run)."
            fi
        else
            info "No changes made to UFW."
        fi
    fi
}

# 4) OpenVPN helper (non-destructive installer + instructions)
install_openvpn() {
    info "OpenVPN install & guidance helper."
    if ! prompt_yes_no "Install and provide OpenVPN guidance?"; then
        return 0
    fi
    if command -v openvpn &>/dev/null; then
        info "OpenVPN already installed."
    else
        if prompt_yes_no "Install OpenVPN package?"; then
            ensure_root_for_apply
            local pm
            pm=$(detect_package_manager)
            install_package "openvpn" "$pm"
            success "OpenVPN installation requested (or shown in dry-run)."
        fi
    fi

    echo
    info "Manual OpenVPN steps (non-destructive):"
    cat <<EOF
1) Place your client .ovpn files in /etc/openvpn/ or /etc/openvpn/client/
2) Enable & start the service (systemctl enable --now openvpn-client@<name>)
3) Verify connectivity with 'openvpn --config /path/to/file.ovpn' or systemctl status
EOF
}

# Check what SSH services are available
systemctl list-unit-files | grep -i ssh

# Common SSH service names:
# - ssh (Debian/Ubuntu)
# - sshd (CentOS/RHEL)
# - ssh.service (some systems)
# 5) SSH Hardening (edits sshd_config with backups + test) - IMPROVED VERSION
harden_ssh() {
    local sshd_cfg="/etc/ssh/sshd_config"
    info "SSH hardening helper (will prompt for each change)."
    
    if [[ ! -f "$sshd_cfg" ]]; then
        err "SSH config not found at $sshd_cfg"
        warn "SSH server might not be installed or using different config path"
        return 1
    fi

    # Enhanced SSH service detection
    info "Detecting SSH service..."
    local ssh_service=""
    
    # Method 1: Check common service names
    for service in ssh sshd openssh-server; do
        if systemctl is-active "$service" &>/dev/null; then
            ssh_service="$service"
            break
        fi
    done
    
    # Method 2: Check service files
    if [[ -z "$ssh_service" ]]; then
        for service in ssh sshd openssh-server; do
            if systemctl list-unit-files | grep -q "^${service}.service"; then
                ssh_service="$service"
                break
            fi
        done
    fi
    
    # Method 3: Check running processes
    if [[ -z "$ssh_service" ]]; then
        if pgrep -x "sshd" >/dev/null; then
            ssh_service="sshd"
        fi
    fi

    if [[ -z "$ssh_service" ]]; then
        warn "Could not detect SSH service name automatically"
        info "Common SSH service names: ssh, sshd, openssh-server"
        read -rp "Enter SSH service name (or press Enter to skip service restart): " ssh_service
    else
        success "Detected SSH service: $ssh_service"
    fi

    if ! prompt_yes_no "Proceed to review and optionally harden SSH config?"; then
        return 0
    fi

    make_backup_dir
    create_backup "$sshd_cfg"

    local temp
    temp="$(mktemp)"
    cp -a -- "$sshd_cfg" "$temp"

    # interactive prompts for common hardening options
    if prompt_yes_no "Disable root login?"; then
        sed -i 's/^#\?PermitRootLogin.*/PermitRootLogin no/' "$temp" || echo "PermitRootLogin no" >> "$temp"
        info "Will set PermitRootLogin no"
    fi
    if prompt_yes_no "Disable password authentication (require keys)?"; then
        sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication no/' "$temp" || echo "PasswordAuthentication no" >> "$temp"
        info "Will set PasswordAuthentication no"
    fi
    if prompt_yes_no "Set MaxAuthTries=3?"; then
        sed -i 's/^#\?MaxAuthTries.*/MaxAuthTries 3/' "$temp" || echo "MaxAuthTries 3" >> "$temp"
        info "Will set MaxAuthTries 3"
    fi
    if prompt_yes_no "Disable X11 forwarding?"; then
        sed -i 's/^#\?X11Forwarding.*/X11Forwarding no/' "$temp" || echo "X11Forwarding no" >> "$temp"
        info "Will set X11Forwarding no"
    fi

    echo "---- Diff (current -> proposed) ----"
    diff -u "$sshd_cfg" "$temp" || true
    echo "-------------------------------------"

    if prompt_yes_no "Apply these SSH changes? (will test config before restart)"; then
        ensure_root_for_apply
        run_cmd "cp -a -- '$temp' '$sshd_cfg'"
        run_cmd "chmod 600 '$sshd_cfg'"
        if [[ $DRY_RUN -eq 1 ]]; then
            info "[DRY-RUN] Would test sshd -t and restart SSH service"
        else
            # Test SSH config
            if sshd -t -f "$sshd_cfg" 2>/dev/null; then
                success "SSH config test passed"
                # Restart service if we know the name
                if [[ -n "$ssh_service" ]]; then
                    run_cmd "systemctl restart $ssh_service"
                    success "SSH config applied and $ssh_service restarted"
                else
                    warn "SSH config applied but service not restarted (unknown service name)"
                    info "You may need to manually restart SSH: systemctl restart ssh"
                fi
            else
                err "sshd -t failed; restoring backup"
                # try to restore from backup if available
                run_cmd "cp -a -- '$BACKUP_DIR/$(basename "$sshd_cfg").backup.'* '$sshd_cfg' || true"
                err "SSH changes reverted due to configuration error"
            fi
        fi
    else
        info "SSH changes not applied."
    fi
    rm -f "$temp"
}
# 6) Kernel sysctl hardening
harden_sysctl() {
    local sysctl_file="/etc/sysctl.d/99-security-hardening.conf"
    info "Kernel sysctl hardening helper (will write $sysctl_file)."
    if ! prompt_yes_no "Apply kernel hardening settings?"; then
        return 0
    fi

    make_backup_dir
    create_backup "$sysctl_file"

    local content
    read -r -d '' content <<'SYSCTL' || true
# Security Hardening Settings
# Network protection
net.ipv4.ip_forward=0
net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.default.send_redirects=0
net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.default.accept_redirects=0
net.ipv4.conf.all.accept_source_route=0
net.ipv4.conf.default.accept_source_route=0
net.ipv4.conf.all.log_martians=1
net.ipv4.icmp_echo_ignore_broadcasts=1
net.ipv4.icmp_ignore_bogus_error_responses=1
net.ipv4.tcp_syncookies=1
net.ipv6.conf.all.accept_redirects=0
net.ipv6.conf.default.accept_redirects=0
# Kernel security
kernel.dmesg_restrict=1
kernel.kptr_restrict=2
SYSCTL

    echo "---- Proposed sysctl contents ----"
    echo "$content"
    echo "----------------------------------"

    if prompt_yes_no "Write these values to $sysctl_file and apply?"; then
        ensure_root_for_apply
        if [[ $DRY_RUN -eq 1 ]]; then
            echo "[DRY-RUN] write to $sysctl_file and run sysctl -p"
        else
            printf '%s\n' "$content" > "$sysctl_file"
            if sysctl -p "$sysctl_file" &>/dev/null; then
                success "Kernel settings applied."
            else
                warn "Some settings may require a reboot or were ignored."
            fi
        fi
    fi
}

# 7) Disable unnecessary services
disable_unnecessary_services() {
    info "Check and disable known-legacy services (telnet/rsh/etc.)"
    if ! prompt_yes_no "Scan for and optionally disable legacy services?"; then
        return 0
    fi

    local services=(telnet.socket rsh.socket rexec.socket rlogin.socket)
    local found=()
    for s in "${services[@]}"; do
        if systemctl list-unit-files --type=service 2>/dev/null | grep -q "^${s}"; then
            if systemctl is-enabled "$s" &>/dev/null; then
                found+=("$s")
            fi
        fi
    done

    if [[ ${#found[@]} -eq 0 ]]; then
        success "No legacy services found to disable."
        return 0
    fi

    echo "Found services: ${found[*]}"
    make_backup_dir
    for s in "${found[@]}"; do
        if prompt_yes_no "Disable & mask $s?"; then
            ensure_root_for_apply
            run_cmd "systemctl stop '$s' || true"
            run_cmd "systemctl disable '$s' || true"
            run_cmd "systemctl mask '$s' || true"
            success "Requested disable/mask for $s (or shown in dry-run)."
        fi
    done
}

# 8) Install security tools (fail2ban, rkhunter, chkrootkit, clamav)
install_security_tools() {
    info "Security tools installation helper (fail2ban, clamav, rkhunter, chkrootkit)."
    if ! prompt_yes_no "Install common security tools?"; then
        return 0
    fi

    ensure_root_for_apply

    local pm
    pm=$(detect_package_manager)
    
    if [[ "$pm" == "unknown" ]]; then
        err "No supported package manager detected."
        return 1
    fi

    local tools=(fail2ban clamav rkhunter chkrootkit)
    for t in "${tools[@]}"; do
        if prompt_yes_no "Install $t?"; then
            install_package "$t" "$pm"
            if [[ "$t" == "fail2ban" ]] && [[ $DRY_RUN -eq 0 ]]; then
                run_cmd "systemctl enable fail2ban" || true
                run_cmd "systemctl start fail2ban" || true
            fi
            success "Requested installation of $t (or shown in dry-run)."
        fi
    done
}

# 9) Run security scans (non-destructive if tools missing)
run_security_scans() {
    info "Security scans helper (rkhunter / chkrootkit)."
    if ! prompt_yes_no "Run available security scans now?"; then
        return 0
    fi

    if command -v rkhunter &>/dev/null; then
        if prompt_yes_no "Run rkhunter (update DB then check)?"; then
            ensure_root_for_apply
            run_cmd "rkhunter --update || true"
            run_cmd "rkhunter --propupd || true"
            run_cmd "rkhunter --check --sk || true"
        fi
    else
        warn "rkhunter not installed."
    fi

    if command -v chkrootkit &>/dev/null; then
        if prompt_yes_no "Run chkrootkit?"; then
            ensure_root_for_apply
            run_cmd "chkrootkit || true"
        fi
    else
        warn "chkrootkit not installed."
    fi
}

# 10) Automatic system updates
auto_system_updates() {
    info "Configuring automated system updates..."
    
    local pm
    pm=$(detect_package_manager)
    
    case "$pm" in
        apt)
            # Install unattended-upgrades if not present
            if ! dpkg -l | grep -q unattended-upgrades 2>/dev/null; then
                install_package "unattended-upgrades" "$pm"
            fi
            
            # Configure automatic security updates
            local config_file="/etc/apt/apt.conf.d/20auto-upgrades"
            if prompt_yes_no "Configure automatic security updates for APT?"; then
                ensure_root_for_apply
                cat > "$config_file" << 'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
};
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
Unattended-Upgrade::Remove-New-Unused-Dependencies "true";
Unattended-Upgrade::Remove-Unused-Dependencies "false";
Unattended-Upgrade::Automatic-Reboot "false";
EOF
                success "Configured automatic security updates for APT"
            fi
            ;;
        yum|dnf)
            if prompt_yes_no "Configure automatic updates for $pm?"; then
                ensure_root_for_apply
                if [[ "$pm" == "dnf" ]]; then
                    install_package "dnf-automatic" "$pm"
                    run_cmd "systemctl enable dnf-automatic.timer"
                    run_cmd "systemctl start dnf-automatic.timer"
                else
                    install_package "yum-cron" "$pm"
                    run_cmd "systemctl enable yum-cron"
                    run_cmd "systemctl start yum-cron"
                fi
                success "Configured automatic updates for $pm"
            fi
            ;;
        *)
            warn "Automatic updates not configured for package manager: $pm"
            ;;
    esac
}

# 11) Summary
show_summary() {
    success "linuxh run complete (or simulated in dry-run)."
    echo
    cat <<EOF
SUMMARY
  - Backups (if created): $BACKUP_DIR
  - Log file: $LOG_FILE
  - Dry-run mode: $([ $DRY_RUN -eq 1 ] && echo "YES" || echo "NO")
  - Forced prompts disabled: $([ $FORCE_NO_PROMPT -eq 1 ] && echo "YES" || echo "NO")
EOF
}

# -------------------------
# CLI / Arg parsing
# -------------------------
usage() {
    cat <<EOF
linuxh - Linux Hardening & Inspection Tool (safe-by-default)

Usage: linuxh [OPTIONS] COMMAND

Global options:
  --help, -h           Show this help
  --dry-run            (default) Show what would be done without making changes
  --apply              Actually perform destructive actions (must be root)
  --yes                Auto-confirm prompts (only use with --apply)
  --backup-dir DIR     Set backup directory (default: $BACKUP_DIR_DEFAULT)
  --log-file FILE      Set log file (default: $LOG_FILE_DEFAULT)

Commands:
  analyze                Analyze current network connections for suspicious ports
  manage-processes       Inspect and optionally kill/remove suspicious processes
  ufw                    Configure UFW firewall (install/allow/enable)
  openvpn                Install OpenVPN and provide setup guidance
  ssh                    Interactively harden SSH (/etc/ssh/sshd_config)
  sysctl                 Apply kernel network/sysctl hardening
  services               Disable legacy unnecessary services
  install-tools          Install security tools (fail2ban, rkhunter, chkrootkit, clamav)
  scans                  Run rkhunter/chkrootkit scans (if installed)
  auto-updates           Configure automatic system updates
  all                    Run all modules in safe sequence (will prompt)
  summary                Show summary of last actions / dry-run status

Examples:
  linuxh analyze
  linuxh --apply ssh
  linuxh --apply --yes all
  linuxh --dry-run manage-processes

Important safety:
  - Default mode is --dry-run: nothing destructive will execute.
  - To actually change the system: pass --apply (and run as root).
  - If you pass --yes you will bypass prompts; use carefully.

EOF
}

# Main execution function
main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h) usage; exit 0;;
            --dry-run) DRY_RUN=1; shift ;;
            --apply) DRY_RUN=0; shift ;;
            --yes) FORCE_NO_PROMPT=1; shift ;;
            --backup-dir) BACKUP_DIR="$2"; shift 2 ;;
            --log-file) LOG_FILE="$2"; shift 2 ;;
            analyze|manage-processes|ufw|openvpn|ssh|sysctl|services|install-tools|scans|auto-updates|all|summary)
                COMMANDS+=("$1"); shift ;;
            *) echo "Unknown option: $1"; usage; exit 1 ;;
        esac
    done

    # If no command, show usage
    if [[ ${#COMMANDS[@]} -eq 0 ]]; then
        usage
        exit 0
    fi

    # Ensure log file directory exists and is writable
    local log_dir
    log_dir=$(dirname "$LOG_FILE")
    if [[ $DRY_RUN -eq 0 ]]; then
        if ! mkdir -p "$log_dir" 2>/dev/null || ! touch "$LOG_FILE" 2>/dev/null; then
            # Try alternative log location
            LOG_FILE="/tmp/linuxh_security.log"
            warn "Cannot write to original log file, using: $LOG_FILE"
            touch "$LOG_FILE" 2>/dev/null || {
                echo "Cannot write to log file - check permissions"
                exit 1
            }
        fi
    fi

    # Initialize backup directory
    if [[ -z "$BACKUP_DIR" ]]; then
        BACKUP_DIR="$BACKUP_DIR_DEFAULT"
    fi

    # Run requested commands in order
    for cmd in "${COMMANDS[@]}"; do
        case "$cmd" in
            analyze) analyze_connections ;;
            manage-processes) manage_suspicious_processes ;;
            ufw) setup_ufw_firewall ;;
            openvpn) install_openvpn ;;
            ssh) harden_ssh ;;
            sysctl) harden_sysctl ;;
            services) disable_unnecessary_services ;;
            install-tools) install_security_tools ;;
            scans) run_security_scans ;;
            auto-updates) auto_system_updates ;;
            all)
                analyze_connections
                manage_suspicious_processes
                setup_ufw_firewall
                install_openvpn
                harden_ssh
                harden_sysctl
                disable_unnecessary_services
                install_security_tools
                run_security_scans
                auto_system_updates
                ;;
            summary) show_summary ;;
            *) warn "Unknown command: $cmd"; usage ;;
        esac
        echo
    done

    show_summary
}

# Initialize commands array and run main
declare -a COMMANDS=()
main "$@"
